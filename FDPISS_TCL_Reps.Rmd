---
title: "FEO 384"
output: html_document
---

---
title: "Feos DATA"
output: html_document
---

#Load required packages


```{r}
## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("AnnotationDbi")

## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("AnnotationForge")

install.packages("devtools")

install.packages("dplyr")

install.packages("edgeRun")

## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("edgeR")

## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("GenomicFeatures")

install.packages("ggplot2")

## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("GO.db")

install.packages("gplots")

## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("org.Mm.eg.db")

install.packages("RColorBrewer")

install.packages("reshape")
install.packages("reshape2")

install.packages("C:/Users/timahfeldt/Downloads/Vennerable_1.1.1.1.tar.gz", repos = NULL, type = "source")


install.packages("rJava")

## try http if https is not available
source("https://bioconductor.org/biocLite.R")
biocLite("genefilter")
```

```{r}
library(AnnotationDbi)
library(AnnotationForge)
library(devtools)
library(dplyr)
library(edgeR)
library(GenomicFeatures)
library(ggplot2)
library(GO.db)


library(gplots)
library(org.Mm.eg.db)

library(RColorBrewer)
library(reshape)


library(Vennerable)
library(reshape2)
library(rJava)
library(genefilter)
```


#Change to working directory
#Import Modified Dataset
#check if all genes have a gene name if not erase the row

```{r}
setwd("E:/FEO/Replicate MOFO analysis/Combodeal")

Real_Col_Names <- read.delim("C:/Users/timahfeldt/Downloads/Real_Col_Names.txt")
#feo make sure you change this line when you import the data set, for you it is header=False




TCL1<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M1.unq.refseq.umi.txt")
TCL2<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M2.unq.refseq.umi.txt")
TCL3<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M3.unq.refseq.umi.txt")
TCL5<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M5.unq.refseq.umi.txt")

SCMYO<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/Feo_positive_controls.unq.refseq.umi.SC_and_Myoblast_Raw.txt")


names(TCL1) <- Real_Col_Names$X.1
names(TCL2) <- Real_Col_Names$X.1
names(TCL3) <- Real_Col_Names$X.1
names(TCL5) <- Real_Col_Names$X.1

colnames(TCL1) <- paste("Run1", colnames(TCL1), sep = "_")
colnames(TCL2) <- paste("Run2", colnames(TCL2), sep = "_")
colnames(TCL3) <- paste("Run3", colnames(TCL3), sep = "_")
colnames(TCL5) <- paste("Run5", colnames(TCL5), sep = "_")

Bounddata<- cbind(SCMYO[1:14], TCL1[2:385],TCL2[2:385],TCL3[2:385],TCL5[2:385])
write.table(Bounddata,file="Bounddata.txt",sep="\t", row.names = FALSE)

#THe following takes more computational power, maintains gene names between datasets... bla

#names(TCL1)[1] <- "X"
#names(TCL2)[1] <- "X"
#names(TCL3)[1] <- "X"
#names(TCL5)[1] <- "X"

#data = merge(SCMYO, TCL1, by.X = "X", by.y = "X")
#data2 = merge(data, TCL2, by.X = "X", by.y = "X")
#data3 = merge(data2, TCL3, by.X = "X", by.y = "X")
#data4 = merge(data3, TCL5, by.X = "X", by.y = "X")


#write.table(data4,file="data.txt",sep="\t")

data = Bounddata
#no gene information remove me
data = data[!is.na(data$X),]
#duplicated gene name remove me
data = data[!duplicated(data$X), ]

```



#MDS plot to identify outliers
#-INDEX FUNCTION TO REMOVE DUPLICATE IN gENE sYMBOL 
# DATAALLu30 FUNCTION TO REMOVE ROWS WERE GENE EXPRESSION is low (meaning 2 columns more than 15 and you stay used name 30 in previous versions and so kept the name, also dont forget that the number 15 is completly arbitrary and there are ways to determine what a good cut-off is)
# MDS Plot of the data dataALLU<-data[!duplicated(data$X), ]

```{r fig.width=14, fig.height=12}

dataALL1<-data[,c(2:1550)]
row.names(dataALL1) <- data$X


dataALL1<-dataALL1[apply(dataALL1,1,function(x)sum(abs(x) >= 1) >=1 ),] 


y <- DGEList(counts=dataALL1, genes=row.names(dataALL1))  
y = calcNormFactors(y, na.rm = FALSE)

mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)

COL = colnames(dataALL1)

barplot(y$samples$lib.size*1e-6, names = COL, las=2, ylab="Library size (Tarjey Units)")

SAM <- y$samples$lib.size

write.table(SAM,file="SAM.txt",sep="\t")
write.table(COL,file="COL.txt",sep="\t")

G = cbind(COL, SAM, deparse.level = 1)
F = rbind(COL, SAM, deparse.level = 1)
X = 10000

newG <- subset(G, SAM >= 10000)

GT = t(newG)

write.table(GT,file="GT.txt",sep="\t")

#We filter for samples with lib size >10000

GT2 = GT[1,]

# Write a function to eliminiate samples start with samples that have lower counts than 10000


data2 = data[,GT2,drop=FALSE]
row.names(data2) <- data$X

dataALL2<-data2[apply(data2,1,function(x)sum(abs(x) >= 1) >=1 ),] 
write.table(dataALL2,file="dataALL2.txt",sep="\t")

y <- DGEList(counts=dataALL2, genes=row.names(dataALL2))  
y = calcNormFactors(y)


mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)

#TEST SPOTPICKER:

# plot(mds, pch = 21, col="black", bg="red", asp = 0.5, cex=1.0, xlab="Leading logFC Dimension 1", ylab="Leading logFC Dimension 2") 


plot(mds, pch = 21, col="black", bg="red", asp = 0.5, cex=1.0) 
mds[with(mds, identify(mds$x, mds$y)),]

#Feo playing around with the different parameters of MDS plots

mds<- plotMDS(y, top=100, gene.selection="pairwise",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=100, gene.selection="common",dim.plot=c(1,2), cex=.7, method="bcv")

COL = colnames(dataALL2)

barplot(y$samples$lib.size*1e-6, names = COL, las=2, ylab="Library size (Tarjey Units)")

SAM <- y$samples$lib.size


```


#Looking at batch effects
#Finding a model

```{r fig.width=14, fig.height=12}
#eXAMPLE fILES from Tims data

#mycolorsx <-c("firebrick3","darkgreen","limegreen","blue", "deepskyblue")

#Identity<-factor(c("SN" ,   "SN",  "SN",  "SN",  "SN",  "SN",  "VTA",	"VTA",	"VTA",	"VTA",	"VTA",	"VTA",	"OLF",	"OLF",	"HYP",	"HYP",	"HCRT",	"HCRT",	"HCRT",	"HCRT"	,"HCRT"	,"HCRT"))

#Timepoint<-factor(c("e15.5" ,   "e15.5","p2"	,"p2","adult","adult","e15.5","e15.5","p2","p2","adult","adult","adult","adult","adult","adult",	"e15.5",	"e15.5",	"p0",	"p0",	"adult",	"adult") )

gsub("([Run1])", "\\1_\\1_", "abc and ABC")

XX <- gsub("Run1_*", "Run1", COL) 

Batch <- factor(c(""))

colnames(dataAll2)

Group = factor(paste(Identity,Timepoint,sep=".")) #combine identity and time
design <- model.matrix(~0+Group) #design matrix without intercept
temp = colnames(design) #just get the names, will need for next step
colnames(design) = unlist(lapply(strsplit(temp,"Group"),function(x) x[2])) #remove the word "Group" from names

y <- estimateGLMCommonDisp(y, design) #nice to calculate all 3 forms of dispersion
y <- estimateGLMTrendedDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
plotBCV(y)
```





```{r}
#if you want to do PCA here is how you do it but don't forget that this data is not scaled in any way (FEO this is not done yet work in progress)

x <- cpm(y, log=TRUE, prior.count=3)

# alternative X this actually scaled 

x = cpm(y, normalized.lib.sizes=TRUE, log=FALSE)


library(rgl)
xx <- prcomp(t(x))
biplot(xx,var.axes=FALSE,ylabs=NULL)

plot3d(xx$x,xlab="PC1",ylab="PC2",zlab="PC3",type="h")
spheres3d(xx$x, radius=1000,col=rainbow(length(xx$x[,1])))
grid3d(side="z", at=list(z=0))
text3d(xx$x, text=rownames(xx$x), adj=1.3)

plot(xx, type="lines")
biplot(xx)

#no text
plot3d(xx$x,xlab="PC1",ylab="PC2",zlab="PC3",type="h")
spheres3d(xx$x, radius=1000,col=rainbow(length(xx$x[,1])))
grid3d(side="z", at=list(z=0))



#there are tons of packages available that can help with this analysis
# http://stackoverflow.com/questions/6578355/plotting-pca-biplot-with-ggplot2
#http://planspace.org/2013/02/03/pca-3d-visualization-and-clustering-in-r/


# Whenever you want to play with this, check this page out http://www.statmethods.net/advgraphs/parameters.html

```



```{r}
#Try to summarize the data Mag proposal
setwd("E:/FEO/Replicate MOFO analysis/Combodeal")

TCL1<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M1.unq.refseq.umi.txt")
TCL2<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M2.unq.refseq.umi.txt")
TCL3<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M3.unq.refseq.umi.txt")
TCL5<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/M5.unq.refseq.umi.txt")

TCL1 = TCL1[!is.na(TCL1$X),] 
TCL1 = TCL1[!duplicated(TCL1$X), ]
TCL2 = TCL2[!is.na(TCL2$X),] 
TCL2 = TCL2[!duplicated(TCL2$X), ]
TCL3 = TCL3[!is.na(TCL3$X),] 
TCL3 = TCL3[!duplicated(TCL3$X), ]
TCL5 = TCL5[!is.na(TCL5$X),] 
TCL5 = TCL5[!duplicated(TCL5$X), ]



dTCL1<-TCL1[,c(2:385)]
dTCL2<-TCL2[,c(2:385)]
dTCL3<-TCL3[,c(2:385)]
dTCL5<-TCL5[,c(2:385)]

row.names(dTCL1) <- TCL1$X
row.names(dTCL2) <- TCL2$X
row.names(dTCL3) <- TCL3$X
row.names(dTCL5) <- TCL5$X

pp <- cbind(names=c(rownames(dTCL1), rownames(dTCL2), rownames(dTCL3), rownames(dTCL5)), rbind.fill(list(dTCL1, dTCL2, dTCL3, dTCL5)))


EF <- ddply(pp, .(names), function(x) colSums(x[,-1], na.rm = TRUE))


# Yo After this you do the dance and you have it all summarized
#all the followng stuff has nothing to do with this as we copied it wholesale


SCMYO<- read.delim("E:/FEO/Replicate MOFO analysis/Combodeal/Feo_positive_controls.unq.refseq.umi.SC_and_Myoblast_Raw.txt")
SCMYO = SCMYO[!is.na(SCMYO$X),] 
SCMYO = SCMYO[!duplicated(SCMYO$X), ]

data = merge(SCMYO, EF, by.X = "X", by.y = "names")


colnames(TCL1) <- paste("Run1", colnames(TCL1), sep = "_")
colnames(TCL2) <- paste("Run2", colnames(TCL2), sep = "_")
colnames(TCL3) <- paste("Run3", colnames(TCL3), sep = "_")
colnames(TCL5) <- paste("Run5", colnames(TCL5), sep = "_")

names(TCL1)[1] <- "X"
names(TCL2)[1] <- "X"
names(TCL3)[1] <- "X"
names(TCL5)[1] <- "X"

data = merge(SCMYO, TCL1, by.X = "X", by.y = "X")
data2 = merge(data, TCL2, by.X = "X", by.y = "X")
data3 = merge(data2, TCL3, by.X = "X", by.y = "X")
data4 = merge(data3, TCL5, by.X = "X", by.y = "X")


write.table(data4,file="data.txt",sep="\t")
data = read.delim("data.txt") 
data = data[!is.na(data$X),] 
data = data[!duplicated(data$X), ]
```


#MDS plot to identify outliers
#-INDEX FUNCTION TO REMOVE DUPLICATE IN gENE sYMBOL 
# DATAALLu30 FUNCTION TO REMOVE ROWS WERE GENE EXPRESSION is low (meaning 2 columns more than 15 and you stay used name 30 in previous versions and so kept the name, also dont forget that the number 15 is completly arbitrary and there are ways to determine what a good cut-off is)
# MDS Plot of the data dataALLU<-data[!duplicated(data$X), ]

```{r fig.width=14, fig.height=12}

dataALL1<-data[,c(2:1550)]
row.names(dataALL1) <- data$X
















```{r}
TFLIST <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/Deduped BAM samples/TEST with EMMANUEL/Things for Emmanuel/TFLIST.txt")
SURFACE.PROTEINS <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/ALL SAMPLES 30/SURFACE PROTEINS.txt")
```




```{r}
write.table(SAM,file="SAM.txt",sep="\t")
write.table(COL,file="COL.txt",sep="\t")

G = cbind(COL, SAM, deparse.level = 1)
F = rbind(COL, SAM, deparse.level = 1)
X = 10000

newG <- subset(G, SAM >= 10000)

GT = t(newG)

write.table(GT,file="GT.txt",sep="\t")




#NO MYOD 

data3<-dataALL2[,c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381)]

y <- DGEList(counts=data3, genes=row.names(data3))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=1000, gene.selection="common",dim.plot=c(1,3), cex=.7)

mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(1,3), cex=.7)
mds<- plotMDS(y, top=100, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=20, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=1000, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=1000, gene.selection="common",dim.plot=c(1,3), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(1,4), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(3,4), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(3,5), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(2,3), cex=.7)


#Feo playing around with the different parameters of MDS plots

mds<- plotMDS(y, top=100, gene.selection="pairwise",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=100, gene.selection="common",dim.plot=c(1,2), cex=.7, method="bcv")

# Find out why we can't do the MDS plot with 99 genes



data2 = data[,GT2,drop=FALSE]
row.names(data2) <- data$X

dataALL4<-data2[apply(data2,1,function(x)sum(abs(x) >= 20) >=3 ),] 
write.table(dataALL4,file="dataALL4.txt",sep="\t")

y <- DGEList(counts=dataALL4, genes=row.names(dataALL4))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=1000, gene.selection="common",dim.plot=c(1,3), cex=.7)

mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,3), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(1,3), cex=.7)
mds<- plotMDS(y, top=100, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=20, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=1000, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=1000, gene.selection="common",dim.plot=c(1,3), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(1,4), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(3,4), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(3,5), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(2,3), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(2,1), cex=.7)
mds<- plotMDS(y, top=250, gene.selection="common",dim.plot=c(3,1), cex=.7)








```


# Load Supportive Files (TFLIST, List of Surface molecules or other curated lists)

```{r}
TFLIST <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/Deduped BAM samples/TEST with EMMANUEL/Things for Emmanuel/TFLIST.txt")
SURFACE.PROTEINS <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/ALL SAMPLES 30/SURFACE PROTEINS.txt")
```


```{r}
# This did not work yet Error in quantile.default(x, p = p) :   missing values and NaN's not allowed if 'na.rm' is FALSE, changed some stuff around but it keeps on saying too few rows or other error messages....

data = read.delim("data.txt") 
data = data[!is.na(data$X),] 
data = data[!duplicated(data$X), ]

dataALL1<-data[,c(2:398)]
row.names(dataALL1) <- data$X


dataALL1<-dataALL1[apply(dataALL1,1,function(x)sum(abs(x) >= 1) >=1 ),] 
Directed.seq.Gene.List. <- read.delim("E:/FEO/Directed seq Gene List .txt")

# Test up to this point it works ! 

Test.data = dataALL1

y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y)


mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)

# Test up to this point it works 

Test.data = dataALL1[row.names(dataALL1) %in% TFLIST$V2,]


y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y)


mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,2), cex=.7)
mds<- plotMDS(y, top=500, gene.selection="common",dim.plot=c(1,3), cex=.7)

# Stops working here I believe it is the matrix shape more rows than columns or something similar MDS plot freaks out

Test.data = dataALL1[row.names(dataALL1) %in% Directed.seq.Gene.List.$V2,]



dataALL<-data[,c(1:398)] 
index<-duplicated(dataALL$X)
dataALLU<-dataALL[!duplicated(dataALL$X), ]
row.names(dataALLU) <- dataALLU$X

dataALL3<-dataALLU[,c(2:398)] 
dataALL3<-dataALL3[apply(dataALL3,1,function(x)sum(abs(x) >= 3) >=2 ),] 



Test.data = dataALL3[row.names(dataALL3) %in% Directed.seq.Gene.List.$V2,]

y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=50, gene.selection="common",dim.plot=c(1,2), cex=.7)

Test.data = data[data$X %in% Directed.seq.Gene.List.$V2,]

write.table(Test.data,file="Test.data.txt",sep="\t")
Test.data = read.delim("Test.data.txt") 
Test.data = Test.data[!is.na(Test.data$X),] 
Test.data = Test.data[!duplicated(Test.data$X), ]

TestdataALL1<-Test.data[,c(2:398)]
row.names(TestdataALL1) <- Test.data$X


TestdataALL1<-TestdataALL1[apply(TestdataALL1,1,function(x)sum(abs(x) >= 1) >=1 ),] 


y <- DGEList(counts=TestdataALL1, genes=row.names(TestdataALL1))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=50, gene.selection="common",dim.plot=c(1,2), cex=.7)

Test.data = Test.data[!is.na(Test.data$X),]
row.names(Test.data) <- Test.data$X
Test.data<-Test.data[,c(2:398)]


#Test.data = data[row.names(data) %in% Directed.seq.Gene.List.$V2,]
Test.data<-Test.data[apply(Test.data,1,function(x)sum(abs(x) >= 1) >=1 ),]
 

y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y, method=c("RLE"))

mds<- plotMDS(y, top=50, gene.selection="common",dim.plot=c(1,2), cex=.7)

dataout30<-dataALL30[,c(1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34)]

Test.data = dataout30[row.names(dataout30) %in% Directed.seq.Gene.List.$V2,]

y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=50, gene.selection="common",dim.plot=c(1,2), cex=.7)

write.table(Test.data,file="Feosgenes.txt",sep="\t")


`100MyoControlFibro` <- read.delim("E:/FEO/100MyoControlFibro.txt")
Selected = `100MyoControlFibro`

library(gplots)
plot.data = dataALL1[row.names(dataALL1) %in% Selected$V2,]
plot.y = DGEList(counts=plot.data[,2:397], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
png(


```

# Load functions that will be used later (Venn, or Selection of highly expressed genes etc, Averaging Columns..

```{r}
get.venn = function(x,plot=F) 
{
  comparisons = names(n.genes)[x] 
  temp = data.for.venn[data.for.venn$sets %in% comparisons,] 
  if(plot) plot(venneuler(temp)) 
  comparison.choice = sig.genes[x]
	my.venn = Venn(comparison.choice)
	weights = Weights(my.venn)[Weights(my.venn)>0]
	intersection.list = my.venn@IntersectionSets[names(weights)]
	names(intersection.list) = names(weights) = lapply(lapply(lapply(strsplit(names(intersection.list),""),as.integer),as.logical),function(x) paste(names(comparison.choice)[x],collapse="+"))
	return(list(genes=intersection.list,counts=weights))
}

find.gene = function(gene,comparisons.object)
{
	unlist(strsplit(names(unlist(lapply(comparisons.object$genes,grep,pattern=paste0("^",gene,"$")))),"+",fixed=T))
}

genes.by.comparison = function(comparison)
{
	temp=as.list(do.call(c,comparison$genes))
	names(temp)=NULL
	to.see = lapply(temp,FUN=find.gene,comparisons.object=comparison)
	names(to.see) = unlist(temp)
	counts = unlist(lapply(to.see,length))
	to.see.ordered = to.see[order(counts,decreasing=T)]
	return(to.see.ordered)
}

my.gene = function(gene,object)
{
	object[[grep(gene,names(object),ignore.case=T)]]
}


# To Average columns 

byapply <- function(x, by, fun, ...)
{
    # Create index list
    if (length(by) == 1)
    {
        nc <- ncol(x)
        split.index <- rep(1:ceiling(nc / by), each = by, length.out = nc)
    } else # 'by' is a vector of groups
    {
        nc <- length(by)
        split.index <- by
    }
    index.list <- split(seq(from = 1, to = nc), split.index)

    # Pass index list to fun using sapply() and return object
    sapply(index.list, function(i)
            {
                do.call(fun, list(x[, i], ...))
            })
}

# Run function z <- byapply(x, 2, rowMeans)

#to get standard deviation use genefilter package

# zz <- byapply(x, 2, rowSds)
```

# Make things look nice

```{r fig.width=14, fig.height=12}
mycolors <- c("deepskyblue" ,  "firebrick3", "darkgreen",  "darkgreen",  "deepskyblue",  "deepskyblue",	"firebrick3",	"darkgreen", "darkgreen",	"deepskyblue",	"deepskyblue", "firebrick3",	"darkgreen", "firebrick3", "firebrick3",	"darkgreen","firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3"	,"darkgreen", "grey", "deepskyblue", "firebrick3", "darkgreen", "grey",	"deepskyblue")
Identity<-factor(c("SAT" ,  "X10", "IF",  "IF",  "SAT",	"SAT",	"X10",	"IF", "IF",	"SAT",	"SAT", "X10",	"IF", "X10", "X10",	"IF","X10",	"IF",	"MYO",	"SAT",	"X10",	"IF",	"MYO",	"SAT",	"X10"	,"IF", "MYO", "SAT", "X10", "IF", "MYO",	"SAT"))
Timepoint<-factor(c("FR" , "aza",  "d10","noM", "FR", "FR", "aza", "d10", "noM", "FR", "FR","aza",  "noM", "noM", "aza", "noM", "noM", "d5", "FR", "FR", "noM", "d5", "FR", "FR", "aza","d5","FR","FR","aza",	"d10",	"FR",	"FR") )

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,2), cex=.7)


mycolorsx <-c("darkgreen","grey","deepskyblue","firebrick3")
# This is the best attempt so far!!!
# Original mds plot,

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,2), cex=0.7)

# write to PDF
# modifications, pch symbols, col outline, bg fill color


mds2 <-with(y, plot(mds, pch = c(21:25,21:25) [as.numeric(Timepoint)], col="black", bg= mycolors, asp = 0.5, cex=2.5, xlab="Leading logFC Dimension 1", ylab="Leading logFC Dimension 2"))

# add a legend

legend("topright", legend=levels(Identity), fill= mycolorsx, cex=1.0)
legend("bottomright", legend=levels(Timepoint), pch = c(21:25,21:25), cex=1.1)

title("MDS plot Top 500 genes Dimension 1 and 2")
```

#Create Design Matrix and estimate Dispersion

```{r fig.width=14, fig.height=12}
Group = factor(paste(Identity,Timepoint,sep=".")) #combine identity and time
design <- model.matrix(~0+Group) #design matrix without intercept
temp = colnames(design) #just get the names, will need for next step
colnames(design) = unlist(lapply(strsplit(temp,"Group"),function(x) x[2])) #remove the word "Group" from names

y <- estimateGLMCommonDisp(y, design) #nice to calculate all 3 forms of dispersion
y <- estimateGLMTrendedDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
plotBCV(y)

png(
  "BCV.png",
  width     = 3.25,
  height    = 3.25,
  units     = "in",
  res       = 1200,
  pointsize = 4
)
par(
  mar      = c(5, 5, 2, 2),
  xaxs     = "i",
  yaxs     = "i",
  cex.axis = 2,
  cex.lab  = 2
)
plotBCV(y)
dev.off()

```

#Library Sizes

```{r fig.width=14, fig.height=12}
barplot(y$samples$lib.size*1e-6, col=mycolors, names=Group, las=2, ylab="Library size (Tarjey Units)")
png(
  "Library Sizes.png",
  width     = 3.25,
  height    = 3.25,
  units     = "in",
  res       = 1200,
  pointsize = 4
)
par(
  mar      = c(5, 5, 2, 2),
  xaxs     = "i",
  yaxs     = "i",
  cex.axis = 2,
  cex.lab  = 2
)
barplot(y$samples$lib.size*1e-6, col=mycolors, names=Group, las=2, ylab="Library size (Tarjey Units)")
dev.off()
```

#fit the model and build contrasts

```{r fig.width=14, fig.height=12}
fit <- glmFit(y, design) 
my.contrasts <- makeContrasts(        #long list of contrasts of interest
  SAT.FRvsIF.noM = SAT.FR-IF.noM,
  SAT.FRvsIF.d10 = SAT.FR-IF.d10,
  SAT.FRvsIF.d5 = SAT.FR-IF.d5,
  SAT.FRvsMYO.FR = SAT.FR-MYO.FR,
  SAT.FRvsX10.noM = SAT.FR-X10.noM,
  SAT.FRvsX10.aza = SAT.FR-X10.aza,
  MYO.FRvsIF.noM = MYO.FR-IF.noM,
  MYO.FRvsIF.d10 = MYO.FR-IF.d10,
  MYO.FRvsIF.d5 = MYO.FR-IF.d5,
  MYO.FRvsX10.noM = MYO.FR-X10.noM,
  MYO.FRvsX10.aza = MYO.FR-X10.aza,
  X10.azavsIF.noM = X10.aza-IF.noM,
  X10.azavsIF.d10 = X10.aza-IF.d10,
  X10.azavsIF.d5 = X10.aza-IF.d5,
  X10.azavsX10.noM = X10.aza-X10.noM,
  X10.noMvsIF.noM = X10.noM-IF.noM,
  X10.noMvsIF.d10 = X10.noM-IF.d10,
  X10.noMvsIF.d5 = X10.noM-IF.d5,
  IF.d10vsIF.d5 = IF.d10-IF.d5,
  IF.d10vsIF.noM = IF.d10-IF.noM,
  IF.d5vsIF.noM = IF.d5-IF.noM,
  levels=design) 
```

#this block creates a LIST and saves all model results into it

```{r}
results.list = list()   
for(i in 1:ncol(my.contrasts))
{
  lrt <-glmLRT(fit,contrast=my.contrasts[,i])
  results.list[[i]] = as.data.frame(topTags(lrt,nrow(dataout30))) #NAME!!!
}
names(results.list) = colnames(my.contrasts)

sapply(names(results.list), 
 function (x) write.table(results.list[[x]], file=paste(x, "txt", sep="."), sep="\t")   )

```

#this block uses the previous list of results and subsets to only those genes with FDR < 10%

```{r}
sig.list = list()
for(i in 1:length(results.list))
{
  sig.list[[i]] = results.list[[i]][results.list[[i]]$FDR<=0.1,]
}
names(sig.list) = colnames(my.contrasts)
```

#this creates n.DEG (number of differentially expressed genes) for each comparison

```{r}
n.DEG = sapply(sig.list,nrow)
names(n.DEG) = colnames(my.contrasts)
n.DEG = sort(n.DEG,decreasing=T)

save(n.DEG,file="n.DEG.RData")
save(results.list,file="results.list.RData")
save(sig.list,file="sig.list.RData")
n.DEG
```

#The purpose of this block is to get the data into the right format for subsequent use by the get.venn() function

```{r}
sig.list = sig.list[unlist(lapply(sig.list,nrow))!=0]
sig.genes = lapply(sig.list,function(x) as.character(x$genes)) #get just the gene names from the different comparisons
n.genes = lapply(sig.list,nrow) #same as n.DEG, just rerunning it here
genes = do.call(c,sig.genes) #combine all genes across comparisons into one long vector
comparison.vector = mapply(function(names,n) rep(names,n),as.list(names(n.genes)),n.genes) #this is prep for the venn code
comparison.vector = do.call(c,comparison.vector) #the main result is the next line
data.for.venn = data.frame(elements=as.character(genes),sets=as.character(comparison.vector)) #makes a dataframe for VENN code
```
#Find the Top 20 genes in any comparison based on FDR and make a unique gene list

```{r}
ALL<- do.call(rbind, lapply(results.list, function(dd) { dd[with(dd, order(FDR)),][(1:20), ]}))
#Discard all rows with an FDR >0.05
RRR <- ALL$FDR <0.05
ALLFDR<- ALL[RRR,] #make the list unique
SigGenesunique<-unique(ALLFDR)
write.table(SigGenesunique,file=" SigGenesunique.txt",sep="\t")
```

# Load Supportive Files (TFLIST, List of Surface molecules or other curated lists)

```{r}
TFLIST <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/Deduped BAM samples/TEST with EMMANUEL/Things for Emmanuel/TFLIST.txt")
```
# Intersect with TF LIST

```{r}
XX<- intersect(SigGenesunique$genes, TFLIST$V2)
```

#Prepare heatmap for most important TFs

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% XX,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
png(
  "heatmap10uniqueggsaveTF.png",
  width     = 3.25,
  height    = 3.25,
  units     = "in",
  res       = 1200,
  pointsize = 4
)
par(
  mar      = c(5, 5, 2, 2),
  xaxs     = "i",
  yaxs     = "i",
  cex.axis = 2,
  cex.lab  = 2
)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
dev.off()
```

```{r}
names(n.genes)
comp2gene.SATvsall = get.venn(c(1,2,3,4,5))

```

#Change the FDR to a much more stringent level 

```{r}
#this block creates a LIST and saves all model results into it
results.list = list()   
for(i in 1:ncol(my.contrasts))
{
  lrt <-glmLRT(fit,contrast=my.contrasts[,i])
	results.list[[i]] = as.data.frame(topTags(lrt,nrow(data)))
}
names(results.list) = colnames(my.contrasts)
head(lapply(results.list,head)) #example to see how it looks like (incomplete)

#this block uses the previous list of results and subsets to only those genes with FDR < 10%
sig.list = list()
for(i in 1:length(results.list))
{
	sig.list[[i]] = results.list[[i]][results.list[[i]]$FDR<=0.01,]
}
names(sig.list) = colnames(my.contrasts)

#this creates n.DEG (number of differentially expressed genes) for each comparison
n.DEG = sapply(sig.list,nrow)
names(n.DEG) = colnames(my.contrasts)
n.DEG = sort(n.DEG,decreasing=T)

save(n.DEG,file="n.DEG.RData001")
save(results.list,file="results.list.RData001")
save(sig.list,file="sig.list.RData001")

sig.list = sig.list[unlist(lapply(sig.list,nrow))!=0]
sig.genes = lapply(sig.list,function(x) as.character(x$genes)) #get just the gene names from the different comparisons
n.genes = lapply(sig.list,nrow) #same as n.DEG, just rerunning it here
genes = do.call(c,sig.genes) #combine all genes across comparisons into one long vector
comparison.vector = mapply(function(names,n) rep(names,n),as.list(names(n.genes)),n.genes) #this is prep for the venn code
comparison.vector = do.call(c,comparison.vector) #the main result is the next line
data.for.venn = data.frame(elements=as.character(genes),sets=as.character(comparison.vector)) #makes a dataframe for VENN code

```

#Example Venn

```{r}
names(n.genes)
comp2gene.SATvsall = get.venn(c(1,2,3,4,5))
comp2gene.SATvsall$genes
BBB<- comp2gene.SATvsall$genes$`SAT.FRvsIF.noM+SAT.FRvsIF.d10+SAT.FRvsIF.d5+SAT.FRvsMYO.FR+SAT.FRvsX10.noM`
```

##Heatmap for the SAT VENN

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% BBB,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

pdf('Comp2gene.SATvsall.pdf')
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
dev.off()
```

##Heatmap for the SAT VENN TF

```{r}
BBBX<- intersect(BBB, TFLIST$V2)
```

## Usual suspects missing 5 VENN too stringent!

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% BBBX,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

pdf('Comp2gene.SATvsall.pdf')
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
dev.off()
```

#Find the Top 100 genes in any comparison based on FDR and make a unique gene list

```{r}
ALL<- do.call(rbind, lapply(results.list, function(dd) { dd[with(dd, order(FDR)),][(1:100), ]}))
#Discard all rows with an FDR >0.05
RRR <- ALL$FDR <0.01
ALLFDR<- ALL[RRR,] #make the list unique
SigGenesunique<-unique(ALLFDR)
write.table(SigGenesunique,file=" SigGenesunique100.txt",sep="\t")
```

# Intersect with TF LIST

```{r}
XX<- intersect(SigGenesunique$genes, TFLIST$V2)
```

#Prepare heatmap for most important TFs

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% XX,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

#Example for selecting samples (bad)
plot.data = dataout30[row.names(dataout30) %in% XX,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y[,c(1,4,5,9,10,13,14,15)],cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

#Prepare heatmap for most important TFs

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% SigGenesunique$genes,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

```


#goseq analysis SAT.FRvsIFNOM

```{r fig.width=14, fig.height=12}
library(goseq)
assayed.genes<-row.names(dataout30)
de.genes<-sig.genes$SAT.FRvsIF.noM
gene.vector=as.integer(assayed.genes%in%de.genes)
names(gene.vector)=assayed.genes
pwf=nullp(gene.vector,"mm9","geneSymbol")
```

#Using the Wallenius approximation GO.Wall

```{r}
GO.wall=goseq(pwf,"mm9","geneSymbol")
head(GO.wall)
```

```{r}
enriched.GO=GO.wall$category[p.adjust(GO.wall$over_represented_pvalue, method="BH")<=1] #No significance
head(enriched.GO)
```

#Interpret the results using GO.db

```{r}
library(GO.db)
for(go in enriched.GO[1:10]){
print(GOTERM[[go]])
cat("--------------------------------------\n")
}
```

#Play with the MDS Plot corrected the labels


```{r fig.width=14, fig.height=12}
mycolors <- c("deepskyblue" ,  "firebrick3", "darkgreen",  "darkgreen",  "deepskyblue",  "deepskyblue",  "firebrick3",	"darkgreen", "darkgreen",	"deepskyblue",	"deepskyblue", "firebrick3",	"darkgreen", "firebrick3", "firebrick3",	"darkgreen","firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3"	,"darkgreen", "grey", "deepskyblue", "firebrick3", "darkgreen", "grey",	"deepskyblue")
Identity<-factor(c("SAT" ,  "X10", "IF",  "IF",  "SAT",	"SAT",	"X10",	"IF", "IF",	"SAT",	"SAT", "X10",	"IF", "X10", "X10",	"IF","X10",	"IF",	"MYO",	"SAT",	"X10",	"IF",	"MYO",	"SAT",	"X10"	,"IF", "MYO", "SAT", "X10", "IF", "MYO",	"SAT"))
Timepoint<-factor(c("FR" , "d5aza",  "d10","noM", "FR", "FR", "d10aza", "d10", "noM", "FR", "FR","d10aza",  "noM", "noM", "d10aza", "noM", "noM", "d5", "FR", "FR", "noM", "d5", "FR", "FR", "d5aza","d5","FR","FR","d5aza",	"d10",	"FR",	"FR") )

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,2), cex=.7)


mycolorsx <-c("darkgreen","grey","deepskyblue","firebrick3")
# This is the best attempt so far!!!
# Original mds plot,

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,2), cex=0.7)

# write to PDF
# modifications, pch symbols, col outline, bg fill color


mds2 <-with(y, plot(mds, pch = c(21:25,21:25) [as.numeric(Timepoint)], col="black", bg= mycolors, asp = 0.5, cex=2.5, xlab="Leading logFC Dimension 1", ylab="Leading logFC Dimension 2"))

# add a legend

legend("topright", legend=levels(Identity), fill= mycolorsx, cex=1.0)
legend("bottomright", legend=levels(Timepoint), pch = c(21:25,21:25), cex=1.1)

title("MDS plot Top 500 genes Dimension 1 and 2")
```

#Play with the MDS Plot corrected the labels dimension 1 and 3


```{r fig.width=14, fig.height=12}
mycolors <- c("deepskyblue" ,  "firebrick3", "darkgreen",  "darkgreen",  "deepskyblue",  "deepskyblue",  "firebrick3",  "darkgreen", "darkgreen",	"deepskyblue",	"deepskyblue", "firebrick3",	"darkgreen", "firebrick3", "firebrick3",	"darkgreen","firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3"	,"darkgreen", "grey", "deepskyblue", "firebrick3", "darkgreen", "grey",	"deepskyblue")
Identity<-factor(c("SAT" ,  "X10", "IF",  "IF",  "SAT",	"SAT",	"X10",	"IF", "IF",	"SAT",	"SAT", "X10",	"IF", "X10", "X10",	"IF","X10",	"IF",	"MYO",	"SAT",	"X10",	"IF",	"MYO",	"SAT",	"X10"	,"IF", "MYO", "SAT", "X10", "IF", "MYO",	"SAT"))
Timepoint<-factor(c("FR" , "d5aza",  "d10","noM", "FR", "FR", "d10aza", "d10", "noM", "FR", "FR","d10aza",  "noM", "noM", "d10aza", "noM", "noM", "d5", "FR", "FR", "noM", "d5", "FR", "FR", "d5aza","d5","FR","FR","d5aza",	"d10",	"FR",	"FR") )

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,3), cex=.7)


mycolorsx <-c("darkgreen","grey","deepskyblue","firebrick3")
# This is the best attempt so far!!!
# Original mds plot,

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,3), cex=0.7)

# write to PDF
# modifications, pch symbols, col outline, bg fill color


mds2 <-with(y, plot(mds, pch = c(21:25,21:25) [as.numeric(Timepoint)], col="black", bg= mycolors, asp = 0.5, cex=2.5, xlab="Leading logFC Dimension 1", ylab="Leading logFC Dimension 3"))

# add a legend

legend("topright", legend=levels(Identity), fill= mycolorsx, cex=1.0)
legend("bottomright", legend=levels(Timepoint), pch = c(21:25,21:25), cex=1.1)

title("MDS plot Top 500 genes Dimension 1 and 3")
```

#Play with the MDS Plot corrected the labels dimension 1 and 4 (dimension 4 depicting the action of aza and potentially positive feed forward loops)


```{r fig.width=14, fig.height=12}
mycolors <- c("deepskyblue" ,  "firebrick3", "darkgreen",  "darkgreen",  "deepskyblue",  "deepskyblue",  "firebrick3",  "darkgreen", "darkgreen",  "deepskyblue",	"deepskyblue", "firebrick3",	"darkgreen", "firebrick3", "firebrick3",	"darkgreen","firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3"	,"darkgreen", "grey", "deepskyblue", "firebrick3", "darkgreen", "grey",	"deepskyblue")
Identity<-factor(c("SAT" ,  "X10", "IF",  "IF",  "SAT",	"SAT",	"X10",	"IF", "IF",	"SAT",	"SAT", "X10",	"IF", "X10", "X10",	"IF","X10",	"IF",	"MYO",	"SAT",	"X10",	"IF",	"MYO",	"SAT",	"X10"	,"IF", "MYO", "SAT", "X10", "IF", "MYO",	"SAT"))
Timepoint<-factor(c("FR" , "d5aza",  "d10","noM", "FR", "FR", "d10aza", "d10", "noM", "FR", "FR","d10aza",  "noM", "noM", "d10aza", "noM", "noM", "d5", "FR", "FR", "noM", "d5", "FR", "FR", "d5aza","d5","FR","FR","d5aza",	"d10",	"FR",	"FR") )

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,4), cex=.7)


mycolorsx <-c("darkgreen","grey","deepskyblue","firebrick3")
# This is the best attempt so far!!!
# Original mds plot,

mds<- plotMDS(y, top=500, col=mycolors, gene.selection="common",dim.plot=c(1,4), cex=0.7)

# write to PDF
# modifications, pch symbols, col outline, bg fill color


mds2 <-with(y, plot(mds, pch = c(21:25,21:25) [as.numeric(Timepoint)], col="black", bg= mycolors, asp = 0.5, cex=2.5, xlab="Leading logFC Dimension 1", ylab="Leading logFC Dimension 4"))

# add a legend

legend("topright", legend=levels(Identity), fill= mycolorsx, cex=1.0)
legend("bottomright", legend=levels(Timepoint), pch = c(21:25,21:25), cex=1.1)

title("MDS plot Top 500 genes Dimension 1 and 4")
```

# Play with number of significant genes

```{r}
ALL<- do.call(rbind, lapply(results.list, function(dd) { dd[with(dd, order(FDR)),][(1:10), ]}))
#Discard all rows with an FDR >0.05
RRR <- ALL$FDR <0.05
ALLFDR<- ALL[RRR,] #make the list unique
SigGenesunique<-unique(ALLFDR)
write.table(SigGenesunique,file=" SigGenesunique.txt",sep="\t")
```

# Load Supportive Files (TFLIST, List of Surface molecules or other curated lists)

```{r}
TFLIST <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/Deduped BAM samples/TEST with EMMANUEL/Things for Emmanuel/TFLIST.txt")
```
# Intersect with TF LIST

```{r}
XX<- intersect(SigGenesunique$genes, TFLIST$V2)
```

#Prepare heatmap for most important TFs

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% XX,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

```


#Prepare heatmap for most important TFs

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% SigGenesunique$genes,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

```
#Prepare Housekeeping gene comparison
```{r fig.width=14, fig.height=12}

HK_genesmm9 <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/HK_genesmm9.txt")

library(gplots)
plot.data = dataout30[row.names(dataout30) %in% HK_genesmm9$V2,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")

```




# weird intersect for special MDS FEO

#MDS plot to identify outliers
#-INDEX FUNCTION TO REMOVE DUPLICATE IN gENE sYMBOL 
# DATAALLu30 FUNCTION TO REMOVE ROWS WERE GENE EXPRESSION is low (meaning 2 columns more than 15 and you stay used name 30 in previous versions and so kept the name, also dont forget that the number 15 is completly arbitrary and there are ways to determine what a good cut-off is)
# MDS Plot of the data


```{r}
setwd("E:/DROPBOX/Dropbox/TIM FEO/RNA SEQ ANAL")
TAB.UMI.REFSEQ.ALL <- read.delim("E:/DGE/TAB UMI REFSEQ ALL.txt")
data <- TAB.UMI.REFSEQ.ALL
data = data[!is.na(data$SYMBOL),]

dataALL<-data[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35)] 
index<-duplicated(dataALL$SYMBOL)
dataALLU<-dataALL[!duplicated(dataALL$SYMBOL), ]
row.names(dataALLU) <- dataALLU$SYMBOL

dataALL30<-dataALLU[,c(2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35)] 
dataALL30<-dataALL30[apply(dataALL30,1,function(x)sum(abs(x) >= 15) >=2 ),] 


Directed.seq.Gene.List. <- read.delim("C:/Users/timahfeldt/Desktop/Directed seq Gene List .txt")
Test.data = dataALL30[row.names(dataALL30) %in% Directed.seq.Gene.List.$V2,]

y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=50, gene.selection="common",dim.plot=c(1,2), cex=.7)

dataout30<-dataALL30[,c(1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34)]

Test.data = dataout30[row.names(dataout30) %in% Directed.seq.Gene.List.$V2,]

y <- DGEList(counts=Test.data, genes=row.names(Test.data))  
y = calcNormFactors(y)

mds<- plotMDS(y, top=50, gene.selection="common",dim.plot=c(1,2), cex=.7)

write.table(Test.data,file="Feosgenes.txt",sep="\t")

```



# Load functions that will be used later (Venn, or Selection of highly expressed genes etc, Averaging Columns..

```{r}
get.venn = function(x,plot=F) 
{
  comparisons = names(n.genes)[x] 
  temp = data.for.venn[data.for.venn$sets %in% comparisons,] 
  if(plot) plot(venneuler(temp)) 
  comparison.choice = sig.genes[x]
	my.venn = Venn(comparison.choice)
	weights = Weights(my.venn)[Weights(my.venn)>0]
	intersection.list = my.venn@IntersectionSets[names(weights)]
	names(intersection.list) = names(weights) = lapply(lapply(lapply(strsplit(names(intersection.list),""),as.integer),as.logical),function(x) paste(names(comparison.choice)[x],collapse="+"))
	return(list(genes=intersection.list,counts=weights))
}

find.gene = function(gene,comparisons.object)
{
	unlist(strsplit(names(unlist(lapply(comparisons.object$genes,grep,pattern=paste0("^",gene,"$")))),"+",fixed=T))
}

genes.by.comparison = function(comparison)
{
	temp=as.list(do.call(c,comparison$genes))
	names(temp)=NULL
	to.see = lapply(temp,FUN=find.gene,comparisons.object=comparison)
	names(to.see) = unlist(temp)
	counts = unlist(lapply(to.see,length))
	to.see.ordered = to.see[order(counts,decreasing=T)]
	return(to.see.ordered)
}

my.gene = function(gene,object)
{
	object[[grep(gene,names(object),ignore.case=T)]]
}


# To Average columns 

byapply <- function(x, by, fun, ...)
{
    # Create index list
    if (length(by) == 1)
    {
        nc <- ncol(x)
        split.index <- rep(1:ceiling(nc / by), each = by, length.out = nc)
    } else # 'by' is a vector of groups
    {
        nc <- length(by)
        split.index <- by
    }
    index.list <- split(seq(from = 1, to = nc), split.index)

    # Pass index list to fun using sapply() and return object
    sapply(index.list, function(i)
            {
                do.call(fun, list(x[, i], ...))
            })
}

# Run function z <- byapply(x, 2, rowMeans)

#to get standard deviation use genefilter package

# zz <- byapply(x, 2, rowSds)
```

# Make things look nice

```{r fig.width=14, fig.height=12}
mycolors <- c("deepskyblue" ,  "firebrick3", "darkgreen",  "darkgreen",  "deepskyblue",  "deepskyblue",	"firebrick3",	"darkgreen", "darkgreen",	"deepskyblue",	"deepskyblue", "firebrick3",	"darkgreen", "firebrick3", "firebrick3",	"darkgreen","firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3",	"darkgreen",	"grey",	"deepskyblue",	"firebrick3"	,"darkgreen", "grey", "deepskyblue", "firebrick3", "darkgreen", "grey",	"deepskyblue")
Identity<-factor(c("SAT" ,  "X10", "IF",  "IF",  "SAT",	"SAT",	"X10",	"IF", "IF",	"SAT",	"SAT", "X10",	"IF", "X10", "X10",	"IF","X10",	"IF",	"MYO",	"SAT",	"X10",	"IF",	"MYO",	"SAT",	"X10"	,"IF", "MYO", "SAT", "X10", "IF", "MYO",	"SAT"))
Timepoint<-factor(c("FR" , "aza",  "d10","noM", "FR", "FR", "aza", "d10", "noM", "FR", "FR","aza",  "noM", "noM", "aza", "noM", "noM", "d5", "FR", "FR", "noM", "d5", "FR", "FR", "aza","d5","FR","FR","aza",	"d10",	"FR",	"FR") )

mds<- plotMDS(y, top=90, col=mycolors, gene.selection="common",dim.plot=c(1,2), cex=.7)


mycolorsx <-c("darkgreen","grey","deepskyblue","firebrick3")
# This is the best attempt so far!!!
# Original mds plot,

mds<- plotMDS(y, top=90, col=mycolors, gene.selection="common",dim.plot=c(1,2), cex=0.7)

# write to PDF
# modifications, pch symbols, col outline, bg fill color


mds2 <-with(y, plot(mds, pch = c(21:25,21:25) [as.numeric(Timepoint)], col="black", bg= mycolors, asp = 0.5, cex=2.5, xlab="Leading logFC Dimension 1", ylab="Leading logFC Dimension 2"))

# add a legend

legend("topright", legend=levels(Identity), fill= mycolorsx, cex=1.0)
legend("bottomright", legend=levels(Timepoint), pch = c(21:25,21:25), cex=1.1)

title("MDS plot Top 50 FEO genes Dimension 1 and 2")
```

#Create Design Matrix and estimate Dispersion

```{r fig.width=14, fig.height=12}
Group = factor(paste(Identity,Timepoint,sep=".")) #combine identity and time
design <- model.matrix(~0+Group) #design matrix without intercept
temp = colnames(design) #just get the names, will need for next step
colnames(design) = unlist(lapply(strsplit(temp,"Group"),function(x) x[2])) #remove the word "Group" from names

y <- estimateGLMCommonDisp(y, design) #nice to calculate all 3 forms of dispersion
y <- estimateGLMTrendedDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
plotBCV(y)

png(
  "BCV.png",
  width     = 3.25,
  height    = 3.25,
  units     = "in",
  res       = 1200,
  pointsize = 4
)
par(
  mar      = c(5, 5, 2, 2),
  xaxs     = "i",
  yaxs     = "i",
  cex.axis = 2,
  cex.lab  = 2
)
plotBCV(y)
dev.off()

```

#Library Sizes

```{r fig.width=14, fig.height=12}
barplot(y$samples$lib.size*1e-6, col=mycolors, names=Group, las=2, ylab="Library size (Tarjey Units)")
png(
  "Library Sizes.png",
  width     = 3.25,
  height    = 3.25,
  units     = "in",
  res       = 1200,
  pointsize = 4
)
par(
  mar      = c(5, 5, 2, 2),
  xaxs     = "i",
  yaxs     = "i",
  cex.axis = 2,
  cex.lab  = 2
)
barplot(y$samples$lib.size*1e-6, col=mycolors, names=Group, las=2, ylab="Library size (Tarjey Units)")
dev.off()
```

#fit the model and build contrasts

```{r fig.width=14, fig.height=12}
fit <- glmFit(y, design) 
my.contrasts <- makeContrasts(        #long list of contrasts of interest
  SAT.FRvsIF.noM = SAT.FR-IF.noM,
  SAT.FRvsIF.d10 = SAT.FR-IF.d10,
  SAT.FRvsIF.d5 = SAT.FR-IF.d5,
  SAT.FRvsMYO.FR = SAT.FR-MYO.FR,
  SAT.FRvsX10.noM = SAT.FR-X10.noM,
  SAT.FRvsX10.aza = SAT.FR-X10.aza,
  MYO.FRvsIF.noM = MYO.FR-IF.noM,
  MYO.FRvsIF.d10 = MYO.FR-IF.d10,
  MYO.FRvsIF.d5 = MYO.FR-IF.d5,
  MYO.FRvsX10.noM = MYO.FR-X10.noM,
  MYO.FRvsX10.aza = MYO.FR-X10.aza,
  X10.azavsIF.noM = X10.aza-IF.noM,
  X10.azavsIF.d10 = X10.aza-IF.d10,
  X10.azavsIF.d5 = X10.aza-IF.d5,
  X10.azavsX10.noM = X10.aza-X10.noM,
  X10.noMvsIF.noM = X10.noM-IF.noM,
  X10.noMvsIF.d10 = X10.noM-IF.d10,
  X10.noMvsIF.d5 = X10.noM-IF.d5,
  IF.d10vsIF.d5 = IF.d10-IF.d5,
  IF.d10vsIF.noM = IF.d10-IF.noM,
  IF.d5vsIF.noM = IF.d5-IF.noM,
  levels=design) 
```

#this block creates a LIST and saves all model results into it

```{r}
results.list = list()   
for(i in 1:ncol(my.contrasts))
{
  lrt <-glmLRT(fit,contrast=my.contrasts[,i])
  results.list[[i]] = as.data.frame(topTags(lrt,nrow(dataout30))) #NAME!!!
}
names(results.list) = colnames(my.contrasts)

sapply(names(results.list), 
 function (x) write.table(results.list[[x]], file=paste(x, "txt", sep="."), sep="\t")   )

```

#this block uses the previous list of results and subsets to only those genes with FDR < 10%

```{r}
sig.list = list()
for(i in 1:length(results.list))
{
  sig.list[[i]] = results.list[[i]][results.list[[i]]$FDR<=0.1,]
}
names(sig.list) = colnames(my.contrasts)
```

#this creates n.DEG (number of differentially expressed genes) for each comparison

```{r}
n.DEG = sapply(sig.list,nrow)
names(n.DEG) = colnames(my.contrasts)
n.DEG = sort(n.DEG,decreasing=T)

save(n.DEG,file="n.DEG.RData")
save(results.list,file="results.list.RData")
save(sig.list,file="sig.list.RData")
n.DEG
```

#The purpose of this block is to get the data into the right format for subsequent use by the get.venn() function

```{r}
sig.list = sig.list[unlist(lapply(sig.list,nrow))!=0]
sig.genes = lapply(sig.list,function(x) as.character(x$genes)) #get just the gene names from the different comparisons
n.genes = lapply(sig.list,nrow) #same as n.DEG, just rerunning it here
genes = do.call(c,sig.genes) #combine all genes across comparisons into one long vector
comparison.vector = mapply(function(names,n) rep(names,n),as.list(names(n.genes)),n.genes) #this is prep for the venn code
comparison.vector = do.call(c,comparison.vector) #the main result is the next line
data.for.venn = data.frame(elements=as.character(genes),sets=as.character(comparison.vector)) #makes a dataframe for VENN code
```
#Find the Top 20 genes in any comparison based on FDR and make a unique gene list

```{r}
ALL<- do.call(rbind, lapply(results.list, function(dd) { dd[with(dd, order(FDR)),][(1:20), ]}))
#Discard all rows with an FDR >0.05
RRR <- ALL$FDR <0.05
ALLFDR<- ALL[RRR,] #make the list unique
SigGenesunique<-unique(ALLFDR)
write.table(SigGenesunique,file=" SigGenesunique.txt",sep="\t")
```

# Load Supportive Files (TFLIST, List of Surface molecules or other curated lists)

```{r}
TFLIST <- read.delim("E:/RNA SEQ ANALYSIS FLOWCELL 1/Deduped BAM samples/TEST with EMMANUEL/Things for Emmanuel/TFLIST.txt")
```
# Intersect with TF LIST

```{r}
XX<- intersect(SigGenesunique$genes, TFLIST$V2)
```

#Prepare heatmap for most important TFs

```{r fig.width=14, fig.height=12}
library(gplots)
plot.data = dataout30[row.names(dataout30) %in% XX,]
plot.y = DGEList(counts=plot.data[,1:32], genes=row.names(plot.data))
plot.y = calcNormFactors(plot.y) #this will normalize the data 
plot.y <- cpm(plot.y, prior.count=2, log=TRUE)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
png(
  "heatmap10uniqueggsaveTF.png",
  width     = 3.25,
  height    = 3.25,
  units     = "in",
  res       = 1200,
  pointsize = 4
)
par(
  mar      = c(5, 5, 2, 2),
  xaxs     = "i",
  yaxs     = "i",
  cex.axis = 2,
  cex.lab  = 2
)
heatmap.2(plot.y,cexCol=0.5, col=brewer.pal(11,"RdBu"),scale="row", trace="none")
dev.off()
```

